> 随记，待整理， 从程序计数器、指令运行角度思考这些以前模糊的知识点，现在格外清晰，当然也有越来越多的疑问，慢慢整理。本周末大概搞懂了如何进入内核代码，如何运行调度代码，内核不是一个进程或线程，以及确定了每个核上都会运行scheduler，往自己核上调度线程，轮廓越来越清晰了。

深入linux内核架构第一章知识点：

1. 系统中每个用户进程自身的虚拟地址范围为0到TASK_SIZE，用户空间之上的区域保留给内核专用，用户进程不能访问。csapp580页图9-26描述了具体的内核虚拟内存，有对每个进程都一样的，有对每个进程都不相同的，但没写明具体区域

2. 64位的机器寻址一般都小于64位，如42位或47位。好处是cpu节省工作量，坏处是虚拟地址空间会包含一些不可寻址的`洞`

3. 用户态切换到内核态的方式，（1）系统调用 （2）异步硬件中断。（暂不确定是否还有其它方式），与进程上下文中进入内核代码不同的是，中断上下文无权访问地址空间，因为中断发生时cpu上的进程可能与中断无关

    `《Linux性能优化实战》中09篇-怎么理解Linux软中断`论述了硬中断和软中断，软中断由内核线程来完成

    [Microprocessor - 8086 Interrupts](https://www.tutorialspoint.com/microprocessor/microprocessor_8086_interrupts.htm) `详细论述了中断的产生与处理过程，对于我来说最想知道的就是中断由硬件产生，然后CPU接到中断事件，执行完当前指令，开始保存CS和IP的值到stack，加载特定的地址到CS和IP寄存器中开始执行中断处理程序`

    Linux Kernel Lab 中的 [Interrupts](https://linux-kernel-labs.github.io/master/lectures/interrupts.html#lecture-objectives) 也有专门的描述。

    比如 `Synchronous interrupts, usually named exceptions, handle conditions detected by the processor itself in the course of executing an instruction. Divide by zero or a system call are examples of exceptions.`

    `Asynchronous interrupts, usually named interrupts, are external events generated by I/O devices. For example a network card generates an interrupts to signal that a packet has arrived.`
    
    其中 `Synchronous interrupts` 就是通常我们说的`异常处理`，这让我产生`每有会意，便欣然忘食`的感觉。

4. 什么情况下会执行内核代码？（1）上一条所说的sysytem call、中断、进/线程切换（三种都涉及CPU上下文切换） （2） 一些特殊的`内核线程`,跟普通线程一样，可被调度，可睡眠，可以有各种用途，比如帮调度器在CPU上分配进程、`处理软中断`。内核线程不与任何用户空间线程相关联，也无权访问用户空间，ps 那些带方括号的就是

5. 正在执行用户态指令的CPU是如何知道时间片用完了？

    
    **电脑上有个硬件设备叫做中断控制器，而CPU上若干个引脚，中断控制器的输出引脚会和CPU的输入引脚链接起来，如果发生中断，对应引脚会收到信号。CPU在执行完一个指令后就会去检查引脚上是否有信号来，如果有就去处理信号（也就是中断函数）。中断函数是提前准备好的（系统启动时），cpu收到信号就去执行。这些流程都是硬件完成的，我们只需要遵循规则就可以了。所以在收到信号和信号处理函数执行之间，是CPU硬件在进行衔接处理。**
    
    **有人可能会疑惑CPU每次执行完指令都去检测引脚信号会不会导致性能问题？实际上不会，这些都是硬件电路完成的，这个检测逻辑处理速度基本就是电信号传递速度，而目前CPU已经很小了，电信号那点传播距离所耗费的时间基本可以忽略。**



**以下是查阅记录：**

- [OS: does the process scheduler runs in separate process](https://stackoverflow.com/a/11769982/9337614)
- [How does the kernel scheduler know how to pre-empt a process?](https://unix.stackexchange.com/a/457586)
- [where does Kernel reside on a multi-core system](https://superuser.com/questions/564660/where-does-kernel-reside-on-a-multi-core-system)
- [Where does scheduler run on multicore system ?](https://www.linuxquestions.org/questions/programming-9/where-does-scheduler-run-on-multicore-system-946804/)

    每个CPU的scheduler仅仅往自己的CPU上调度么？

    probably yes

- [论进程表和内核栈](https://www.cs.umb.edu/~eoneil/cs444_f06/class10.html)


- [For a kernel level process, should the variables be stored in a stack or a heap?](https://www.quora.com/For-a-kernel-level-process-should-the-variables-be-stored-in-a-stack-or-a-heap)

   重点是回答中提到的两个函数` kmalloc` `vmalloc` 
-[where is PCB stored in memory](https://stackoverflow.com/questions/48619363/where-is-pcb-stored-in-memory)
    
    这个回答说龙书写的烂

- [What is Process Control Block (PCB)?](https://www.tutorialspoint.com/what-is-process-control-block-pcb)
    
    这个人说pcb放在内核栈的开始

- [Where is page table stored in Linux?](https://unix.stackexchange.com/questions/487052/where-is-page-table-stored-in-linux)

    这个人问页表存在哪

- [Where is task_struct stored?](https://stackoverflow.com/questions/10604632/where-is-task-struct-stored)

    这个人问进程的数据结构存在哪？页表、task_struct、pcb都暂时没搞明白放在内核空间的什么区域