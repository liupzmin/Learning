#include <stdio.h>

/*

一维数组：int a[4]

（1）一维数组名a是个地址，地址类型为：int *

（2）一维数组名取地址&a是个地址，地址类型同：int (*p)[4]， 也即&a指向含4个int元素的一维数组

备注：a和&a，两者都是个地址，且这两个地址的数值完全相等。

 

再看二维数组b[3][4]，这个二维数组也可以可以看成一个含3个成员的一维数组，每一个成员含有4个int元素，依次，仿照一维数组的结论，有：

（1）b[0]是个一维数组名，也是个地址，地址类型为：int *

（2）&b[0]是个地址，地址类型同：int (*p)[4]， 也即&b[0]指向含4个int元素的一维数组

更进一步：

（3）b是个地址，地址类型同：int (*p)[4]，也即b指向含4个int元素的一维数组

（4）&b是个地址，地址类型同：int (*p)[3][4]，也即&b指向含3x4个int元素的2维数组

注意：尤其注意上面的（3），这条结论指出了：二维数组名实际上是一维数组的地址！

 

总结：

① 数组名，是指向它的第一个一级成员的指针

② 数组名取地址，是指向整个数组的指针

二维数组做指针运算时需要注意：

int a[ROWS][COLS];

int (*p)[COLS];
p = a;

a 指向a[0]；这句话中a[0]是指整个第0行数据，所以潜在的规律是a[i]单独使用时或者与sizeof和&连用时是指整行数据，如果在表达式中则解释为指向i行首元素的地址。

根据 a[i] = *(a + i)的公式可知，a[i][j] = *(*(a + i) + j)，这里的a可以换成p，

*(p+1)单独使用时表示的是第 1 行数据，放在表达式中会被转换为第 1 行数据的首地址，也就是第 1 行第 0 个元素的地址，

因为使用整行数据没有实际的含义，编译器遇到这种情况都会转换为指向该行第 0 个元素的指针

*/

int main()
{
    int b[10] = {[2] = 29, [6]=19};

    printf("b:     %p\n", b);
    printf("&b:    %p\n", &b);
    printf("&b[0]: %p\n", &b[0]);

    printf("\n");

    int *bp = b;
    int (*bp1)[10] = &b;
    int *bp2 = &b[0];

    printf("bp:  %p\n", bp);
    printf("bp1: %p\n", bp1);
    printf("bp2: %p\n", bp2);

    printf("\n");


    int a[2][2] = {
        {1,2},{3,4}
    };

    printf("a:        %p\n", a);
    printf("&a:       %p\n", &a);
    printf("a[0]:     %p\n", a[0]);
    printf("&a[0]:    %p\n", &a[0]);
    printf("&a[0][0]: %p\n", &a[0][0]);

    printf("\n");

    int *p = a[0];
    int (*p1)[2] = a;
    int (*p2)[2] = &a[0];
    int (*p3)[2][2] = &a;
    int *p4 = &a[0][0];

    printf("p:  %p\n", a);
    printf("p1: %p\n", &a);
    printf("p2: %p\n", a[0]);
    printf("p3: %p\n", &a[0]);
    printf("p4: %p\n", &a[0][0]);
    printf("\n");


    return 0;
}